n <- 100
data <- data.frame(
x = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3)),
y = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3))
)
# Plot the initial data
ggplot(data, aes(x, y)) +
geom_point() +
ggtitle("Step 1: Initial Data") +
theme_minimal()
# DBSCAN parameters
eps <- 0.2
minPts <- 5
# Identify core points
db <- dbscan(data, eps = eps, minPts = minPts)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = core)) +
geom_point() +
scale_color_manual(values = c("Core" = "blue", "Noise" = "red")) +
ggtitle("Step 2: Core Points and Noise") +
theme_minimal()
# Cluster formation
data$cluster <- as.factor(db$cluster)
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
# Step-by-step process
plot_dbscan_steps <- function(data, eps, minPts) {
db <- dbscan(data[, 1:2], eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = cluster, shape = core)) +
geom_point(size = 3) +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
scale_shape_manual(values = c("Core" = 16, "Noise" = 1)) +
ggtitle("DBSCAN Clustering Step by Step") +
theme_minimal()
}
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
ggplot(data, aes(x, y, color = core)) +
geom_point() +
scale_color_manual(values = c("Core" = "blue", "Noise" = "red")) +
ggtitle("Step 2: Core Points and Noise") +
theme_minimal()
# Cluster formation
data$cluster <- as.factor(db$cluster)
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
# Step-by-step process
plot_dbscan_steps <- function(data, eps, minPts) {
db <- dbscan(data[, 1:2], eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = cluster, shape = core)) +
geom_point(size = 3) +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
scale_shape_manual(values = c("Core" = 16, "Noise" = 1)) +
ggtitle("DBSCAN Clustering Step by Step") +
theme_minimal()
}
# Plot the final result
plot_dbscan_steps(data, eps, minPts)
library(ggplot2)
library(animation)
library(dbscan)
# Generate sample data for 3 clusters
set.seed(123)
x <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
y <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
data <- data.frame(x, y)
# Perform DBSCAN clustering
db <- dbscan(data, eps = 2, minPts = 5)
# Extract core points and their cluster labels
core_points <- data[db$cluster != 0, ]
core_labels <- db$cluster[db$cluster != 0]
# Function to create animation frames
animate_dbscan <- function(data, db, core_points, core_labels) {
frames <- list()
# Initial frame with all core points in blue and noise in gray
initial_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "blue"), size = 3) +
labs(title = "DBSCAN Clustering (Initial)") +
theme_minimal()
frames[[1]] <- initial_plot
# Vibrant colors for clusters
cluster_colors <- c("#FF0000", "#0000FF", "#00FF00")  # Bright Red, Bright Blue, Bright Green
unique_labels <- unique(core_labels)
frame_counter <- 2
for (cluster_index in seq_along(unique_labels)) {
cluster_label <- unique_labels[cluster_index]
cluster_points <- data[db$cluster == cluster_label, ]
for (point_index in 1:nrow(cluster_points)) {
current_core <- core_points[core_labels == cluster_label, ][1:point_index, ]
p <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = cluster_points[1:point_index, ], aes(x, y), color = cluster_colors[cluster_index], size = 5) +
labs(title = paste("DBSCAN Clustering (Frame", frame_counter, ")")) +
theme_minimal()
frames[[frame_counter]] <- p
frame_counter <- frame_counter + 1
}
}
# Final frame showing all clusters in their respective colors
final_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = core_points, aes(x, y, color = factor(core_labels)), size = 5) +
scale_color_manual(values = cluster_colors) +
labs(title = "DBSCAN Clustering (Final)", color = "Cluster") +
theme_minimal()
frames[[frame_counter]] <- final_plot
return(frames)
}
# Create animation frames
frames <- animate_dbscan(data, db, core_points, core_labels)
# Create animation
ani.options(interval = 0.5)
saveGIF({
for (i in seq_along(frames)) {
print(frames[[i]])
}
}, movie.name = "dbscan_animation.gif", ani.width = 600, ani.height = 600)
# Load necessary libraries
library(ggplot2)
library(dbscan)
# Generate synthetic data
set.seed(42)
n <- 100
data <- data.frame(
x = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3)),
y = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3))
)
# Plot the initial data
ggplot(data, aes(x, y)) +
geom_point() +
ggtitle("Step 1: Initial Data") +
theme_minimal()
# DBSCAN parameters
eps <- 0.2
minPts <- 5
# Identify core points
db <- dbscan(data, eps = eps, minPts = minPts)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = core)) +
geom_point() +
scale_color_manual(values = c("Core" = "blue", "Noise" = "red")) +
ggtitle("Step 2: Core Points and Noise") +
theme_minimal()
# Cluster formation
data$cluster <- as.factor(db$cluster)
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
# Step-by-step process
plot_dbscan_steps <- function(data, eps, minPts) {
db <- dbscan(data[, 1:2], eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = cluster, shape = core)) +
geom_point(size = 3) +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
scale_shape_manual(values = c("Core" = 16, "Noise" = 1)) +
ggtitle("DBSCAN Clustering Step by Step") +
theme_minimal()
}
# Plot the final result
plot_dbscan_steps(data, eps, minPts)
# Load the required packages
library(cluster)
library(factoextra)
library(ggplot2)
# Create a simple dataset with values a, b, c, d, e
data <- matrix(c(
0, 2, 6, 10, 9, # 'a'
2, 0, 5, 9, 8, # 'b'
6, 5, 0, 4, 5, # 'c'
10, 9, 4, 0, 3, # 'd'
9, 8, 5, 3, 0  # 'e'
), nrow = 5, byrow = TRUE)
# Assign row names corresponding to the letters
rownames(data) <- c('a', 'b', 'c', 'd', 'e')
# Compute divisive clustering
res.diana <- diana(data, stand = TRUE)
# Visualize the dendrogram
p <- fviz_dend(res.diana,cex = 1.5, k = 5, palette = "jco", rect = TRUE) +
theme_minimal() +  # Change theme to minimal
theme(axis.text = element_text(color = "black", size = 12),  # Customize axis text
axis.title = element_blank(),  # Remove axis titles
panel.grid.major = element_blank(),  # Remove major gridlines
panel.grid.minor = element_blank(),  # Remove minor gridlines
panel.border = element_blank(),  # Remove panel border
plot.margin = unit(c(1, 1, 1, 1), "cm")) + # Adjust plot margins
ggtitle("DIANA Clustering Dendrogram: Divisive Analysis of Simple Dataset")
# Combine all text labels into a single data frame
text_data <- data.frame(
x = c(2.7, 1.35, 3.58, 4.35),
y = c(4.85, 1.2, 3.9, 1.6),
label = c("{a,b,c,d,e}", "{a,b}", "{c,d,e}", "{d,e}")
)
# Add labels to the dendrogram
p <- p + geom_text(data = text_data, aes(x = x, y = y, label = label),
color = "purple", size = 5, vjust = -1, fontface = "bold")
# Print the dendrogram with labels
print(p)
# Convert matrix to data frame
data_df <- as.data.frame(data)
# Extract cluster observations using cutree function for different numbers of clusters
cluster_1 <- cutree(res.diana, k = 1)
cluster_2 <- cutree(res.diana, k = 2)
cluster_3 <- cutree(res.diana, k = 3)
cluster_4 <- cutree(res.diana, k = 4)
cluster_5 <- cutree(res.diana, k = 5)
# Visualize the clusters in the dendrogram manually for k = 2
p_k2 <- fviz_dend(res.diana, k = 2, cex = 1.5, palette = "jco", rect = TRUE, rect_fill = FALSE)
print(p_k2 + ggtitle("Clustering with k = 2") +
ylab("Step 2"))
# Visualize the clusters in the dendrogram manually for k = 3
p_k3 <- fviz_dend(res.diana, k = 3, cex = 1.5, palette = "jco", rect = TRUE, rect_fill = FALSE)
print(p_k3 + ggtitle("Clustering with k = 3") + ylab("Step 3"))
# Visualize the clusters in the dendrogram manually for k = 4
p_k4 <- fviz_dend(res.diana, k = 4, cex = 1.5, palette = "jco", rect = TRUE, rect_fill = FALSE)
print(p_k4 + ggtitle("Clustering with k = 4") + ylab("Step 4"))
# Visualize the clusters in the dendrogram manually for k = 4
p_k5 <- fviz_dend(res.diana, k = 5, cex = 1.5, palette = "jco", rect = TRUE, rect_fill = FALSE)
print(p_k5 + ggtitle("Clustering with k = 5") + ylab("Step 5"))
#### Single Linkage
########################
set.seed(1115)  # For reproducibility
#### Single Linkage
########################
set.seed(1115)  # For reproducibility
cluster1 <- data.frame(x = rnorm(50, mean = 2), y = rnorm(50, mean = 2), cluster = factor(1))
cluster2 <- data.frame(x = rnorm(50, mean = 8), y = rnorm(50, mean = 8), cluster = factor(2))
data <- rbind(cluster1, cluster2)
# Plot the data
plot(data$x, data$y, col = as.integer(data$cluster), pch = 19,
xlab = "X-axis", ylab = "Y-axis", main = "Single Linkage")
# Calculate pairwise distances
distances <- as.matrix(dist(data[, c("x", "y")]))
# Find the minimum distance between points from different clusters
min_distance <- Inf
closest_points <- c(NA, NA)
for (i in 1:nrow(distances)) {
for (j in (i+1):ncol(distances)) {
if (data[i, "cluster"] != data[j, "cluster"] && distances[i, j] < min_distance) {
min_distance <- distances[i, j]
closest_points <- c(i, j)
}
}
}
# Print the indices of the closest points
closest_points
# Extract coordinates of the two closest points
point1 <- data[closest_points[1], c("x", "y")]
point2 <- data[closest_points[2], c("x", "y")]
# Add a line between the two closest points
lines(c(point1$x, point2$x), c(point1$y, point2$y), col = "green", lwd = 3)
# Add a line between the two closest points
lines(c(point1$x, point2$x), c(point1$y, point2$y), col = "green", lwd = 4)
max_distance <- 0
farthest_points <- c(NA, NA)
for (i in 1:(nrow(distances)-1)) {
for (j in (i+1):ncol(distances)) {
if (data[i, "cluster"] != data[j, "cluster"] && distances[i, j] > max_distance) {
max_distance <- distances[i, j]
farthest_points <- c(i, j)
}
}
}
# Extract coordinates of the two points with maximum distance
point1_max <- data[farthest_points[1], c("x", "y")]
point2_max <- data[farthest_points[2], c("x", "y")]
# Plot the data using base R graphics with ellipses around clusters
plot(data$x, data$y, col = as.integer(data$cluster), pch = 19,
xlab = "X-axis", ylab = "Y-axis", main = "Complete Linkage")
# Add a line between the two points with maximum distance
lines(c(point1_max$x, point2_max$x), c(point1_max$y, point2_max$y), col = "blue", lwd = 4)
distances_between_clusters <- c()
for (i in 1:(nrow(distances)-1)) {
for (j in (i+1):ncol(distances)) {
if (data[i, "cluster"] != data[j, "cluster"]) {
distances_between_clusters <- c(distances_between_clusters, distances[i, j])
}
}
}
# Compute the average distance
average_distance <- mean(distances_between_clusters)
# Print the average distance
average_distance
# Plot the data
plot(data$x, data$y, col = as.integer(data$cluster), pch = 19,
xlab = "X-axis", ylab = "Y-axis", main = "Average Linkage")
# Annotate the average distance
text(x = 5, y = 4.5, labels = paste("Average distance:",
round(average_distance, 2)), col = "black", cex = 2)
# Perform hierarchical clustering using the Ward method
hc <- hclust(dist(data[, c("x", "y")]), method = "ward.D2")
# Calculate the Ward distances
ward_dist <- hc$height
# Print the Ward distance
print(ward_dist)
# Plot the data
plot(data$x, data$y, col = as.integer(data$cluster), pch = 19,
xlab = "X-axis", ylab = "Y-axis", main = "Ward Distance")
# Add annotation
text(x = 5, y = 4.5,
labels = "Die Vereinigung der beiden Cluster minimiert die Within−Varianz", pos = 3, cex = 2)
# Set seed for reproducibility
set.seed(1750)
# Generate sample data
data <- matrix(rnorm(100*2), ncol=2)
# Compute within-cluster sum of squares for different numbers of clusters
wcss <- numeric(10)
for (k in 1:10) {
kmeans_result <- kmeans(data, centers = k, nstart = 25, algorithm = "Lloyd")
wcss[k] <- kmeans_result$tot.withinss
}
# Create the scree plot using ggplot2
ggplot(wcss_df, aes(x = Clusters, y = WCSS)) +
geom_point(size = 3, color = "blue") +
geom_line(size = 1, color = "blue") +
geom_text(aes(label = round(WCSS, 2)), vjust = -1, color = "black") +  # Add text labels for WCSS values
ggtitle("Scree Plot for K-means Clustering using Lloyd's Algorithm") +
xlab("Number of Clusters") +
ylab("Within-variance") +
scale_x_continuous(breaks = 1:10) +  # Ensure all x-axis values are shown
scale_y_continuous() +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
# Generate sample data from two normal distributions
set.seed(1823)
data1 <- rnorm(1000, mean = 0, sd = 1)
data2 <- rnorm(1000, mean = 3, sd = 1)
data <- c(data1, data2)
# Kernel density estimation for mixed distribution
density_mix <- density(data)
# Plot the kernel density
plot(density_mix, main = "Kernel Density Plot for Mixed Distribution",
xlab = "X", ylab = "Density")
# Load necessary libraries
library(ggplot2)
library(dbscan)
# Generate synthetic data
set.seed(42)
n <- 100
data <- data.frame(
x = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3)),
y = c(rnorm(n, mean = 0, sd = 0.3), rnorm(n, mean = 1, sd = 0.3))
)
# Plot the initial data
ggplot(data, aes(x, y)) +
geom_point() +
ggtitle("Step 1: Initial Data") +
theme_minimal()
# DBSCAN parameters
eps <- 0.2
minPts <- 5
# Identify core points
db <- dbscan(data, eps = eps, minPts = minPts)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = core)) +
geom_point() +
scale_color_manual(values = c("Core" = "blue", "Noise" = "red")) +
ggtitle("Step 2: Core Points and Noise") +
theme_minimal()
# Cluster formation
data$cluster <- as.factor(db$cluster)
ggplot(data, aes(x, y, color = cluster)) +
geom_point() +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
ggtitle("Step 3: Cluster Formation") +
theme_minimal()
# Step-by-step process
plot_dbscan_steps <- function(data, eps, minPts) {
db <- dbscan(data[, 1:2], eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
data$core <- ifelse(db$cluster > 0, "Core", "Noise")
ggplot(data, aes(x, y, color = cluster, shape = core)) +
geom_point(size = 3) +
scale_color_manual(values = c("0" = "red", "1" = "blue", "2" = "green")) +
scale_shape_manual(values = c("Core" = 16, "Noise" = 1)) +
ggtitle("DBSCAN Clustering Step by Step") +
theme_minimal()
}
# Plot the final result
plot_dbscan_steps(data, eps, minPts)
library(ggplot2)
library(animation)
library(dbscan)
# Generate sample data for 3 clusters
set.seed(123)
x <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
y <- c(rnorm(50, 0, 2), rnorm(50, 8, 2), rnorm(50, -8, 2))
data <- data.frame(x, y)
# Perform DBSCAN clustering
db <- dbscan(data, eps = 2, minPts = 5)
# Extract core points and their cluster labels
core_points <- data[db$cluster != 0, ]
core_labels <- db$cluster[db$cluster != 0]
# Function to create animation frames
animate_dbscan <- function(data, db, core_points, core_labels) {
frames <- list()
# Initial frame with all core points in blue and noise in gray
initial_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "blue"), size = 3) +
labs(title = "DBSCAN Clustering (Initial)") +
theme_minimal()
frames[[1]] <- initial_plot
# Clusters
cluster_colors <- c("#FF0000", "#0000FF", "#00FF00")  # Red, Blue, Green
unique_labels <- unique(core_labels)
frame_counter <- 2
for (cluster_index in seq_along(unique_labels)) {
cluster_label <- unique_labels[cluster_index]
cluster_points <- data[db$cluster == cluster_label, ]
for (point_index in 1:nrow(cluster_points)) {
current_core <- core_points[core_labels == cluster_label, ][1:point_index, ]
p <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = cluster_points[1:point_index, ], aes(x, y), color = cluster_colors[cluster_index], size = 5) +
labs(title = paste("DBSCAN Clustering (Frame", frame_counter, ")")) +
theme_minimal()
frames[[frame_counter]] <- p
frame_counter <- frame_counter + 1
}
}
# Final frame showing all clusters in their respective colors
final_plot <- ggplot() +
geom_point(data = data, aes(x, y), color = ifelse(db$cluster == 0, "black", "gray80"), size = 3) +
geom_point(data = core_points, aes(x, y, color = factor(core_labels)), size = 5) +
scale_color_manual(values = cluster_colors) +
labs(title = "DBSCAN Clustering (Final)", color = "Cluster") +
theme_minimal()
frames[[frame_counter]] <- final_plot
return(frames)
}
# Create animation frames
frames <- animate_dbscan(data, db, core_points, core_labels)
# Create animation
ani.options(interval = 0.5)
saveGIF({
for (i in seq_along(frames)) {
print(frames[[i]])
}
}, movie.name = "dbscan_animation.gif", ani.width = 600, ani.height = 600)
library(pan)
?pan
library(mice)
methods(mice)
?mice.impute.pmm
library(Amelia)
?amelia
Data_Imputation_mice <- function(data, m = 2, maxit = 5, method = 'pmm') {
# Lagged exogenous variables
data$Lagged_MaritalStatus <- lag(data$MaritalStatus, 1)
data$Lagged_Sex <- lag(data$Sex, 1)  # Replace lagged EmploymentHours with lagged Sex
ID <- data$ID
Year <- data$Year
EmploymentTypes <- data$EmploymentTypes
MaritalStatus <- data$MaritalStatus
EmploymentHours <- data$EmploymentHours
Education <- data$Education
Sex <- data$Sex
# Create the temporary dataset for imputation, now including lagged Sex
DataTemp <- data[c("Lagged_MaritalStatus", "Lagged_Sex", "Age", "Income", "Education", "Sex")]
# Perform MICE imputation
miceImp <- mice(DataTemp, method = method, m = m, maxit = maxit)
# Re-add the ID, Year, EmploymentTypes, MaritalStatus, EmploymentHours, Education, and Sex columns
CompleteDataset <- lapply(1:m, function(i) {
CompleteData <- complete(miceImp, action = i)
CompleteData <- cbind(ID = ID,
Year = Year,
EmploymentTypes = EmploymentTypes,
MaritalStatus = MaritalStatus,
EmploymentHours = EmploymentHours,
Education = Education,
Sex = Sex,
CompleteData)
CompleteData <- CompleteData[c("ID", "Year", "Age", "EmploymentTypes", "Income", "MaritalStatus", "EmploymentHours", "Education", "Sex")]
return(CompleteData)
})
return(CompleteDataset)  # Return a list of completed datasets
}
mice_bal_mcar_50 <- Data_Imputation_mice(balanced_panel_data_mcar_50)
RawData
515+250+150+40+5+6+3.15
515+250+150+40+5+6+4+6
4611/2
1600-1250
350-200
1250*138
1500*12*5
1500*12*4
setwd("/Users/tipusultan/Documents/GitHub/PokemonAnalysis")
Pokemon = read.csv("pokemon.csv", header = TRUE)
#Pokemon = read.csv(file.choose())
View(Pokemon)
colnames(Pokemon)
